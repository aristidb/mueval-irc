WHAT:
Mueval grew out of my discontent with Lambdabot: it's really neat to be able to run expressions like this:

07:53 < ivanm> > filter (\ x -> isLetter x || x == '\t') "asdf$#$     dfs"
07:55 < lambdabot>  "asdfdfs"

But Lambdabot is crufty and very difficult to install or run. IMO, we need a replacement or rewrite, but one of the things that make this difficult is that Lambdabot uses hs-plugins to get that sort of evaluation functionality, and hs-plugins is half the problem. We want some sort of standalone executable which provides that functionality. Now, 'ghc -e' is obviously unsuited because there is no sandboxing, so what I've done is basically marry the GHC API (as rendered less sharp-edged by Hint) with a bunch of resource limits and sandboxing (as largely stolen from Lambdabot).

EXAMPLES:
The end result is an adorable little program, which you can use like this:

 bash-3.2$ mueval --expression '1*100+1'
 Expression type: (Num t) => t
 result: "101"

 bash-3.2$ mueval --expression "filter (\`notElem\` ['A'..'Z']) \"abcXsdzWEE\""
 Expression type: [Char]
 result: "\"abcsdz\""

Note that mueval will avoid all the attacks I've been able to test on it:

 bash-3.2$ mueval --expression 'let x = x in x'
 Expression type: t
 result: "mueval: Time limit exceeded

 bash-3.2$ mueval --expression "let foo = readFile \"/etc/passwd\" >>= print in foo"
 Expression type: IO ()
 result: "<IO ()>"

 bash-3.2$ mueval --module System.IO.Unsafe --expression "let foo = unsafePerformIO readFile \"/etc/passwd\" in foo"
 mueval: Unknown or untrusted module supplied! Aborting.

LOADING FROM FILE:
Like Lambdabot, Mueval is capable of loading a file and its definitions. This is useful to get a kind of persistence. Suppose you have a file "L.hs", with a function 'bar = (+1)' in it; then 'mueval --loadfile=L.hs --expression="bar 1"' will evaluate to, as one would expect, '2'.

It's worth noting that definitions and module imports in the loaded *ARE NOT* fully checked like the expression is. The resource limits and timeouts still apply, but little else. So if you are dynamically adding functions and module imports, you *MUST* secure them yourself or accept the loss of security. Currently, all known 'evil' expressions cause Mueval to exit with an error (a non-zero exit code), so my advice is to do something like 'mueval --expression foo && echo "\n" >> L.hs && echo foo >> L.hs'.

SUMMARY:
Anyway, it's my hope that this will be useful as an example or useful in itself for people endeavouring to fix the Lambdabot situation or just in safely running code period.

GETTING:
You can download Mueval at the usual place: <http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval>. Mueval has a public darcs repository, at <http://code.haskell.org/mubot/> (in the mueval/ subdirectory). Contributions are of course welcomed.

INSTALLING:
Mueval depends on a few of the standard libraries, which you should have installed already, and also on the 'Hint' library <http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint>; Hint is particularly essential as it is the very capable wrapper around the GHC API which Mueval uses. (Without Hint, this would've been even more painful to write). All of this is cabalized, so ideally installation will be as simple as:

 sh$ cabal install mueval

(Note that as of 23 August 2008, you will need to build haskell-src-exts from its Darcs repository at <http://code.haskell.org/HSP/haskell-src-exts>, as version 0.3.6 has not been uploaded to Hackage.)

However, you can still manually download and unpack the Mueval tarball, and do the usual Cabal dance:

 sh$ runhaskell Setup configure
 sh$ runhaskell Setup build
 sh$ runhaskell Setup install

BUGS:
Mueval uses a number of techniques for security; particularly problematic seem to be the resource limits, as they have to be specified manually & statically in the source code and so will probably be broken somewhere somewhen. For this reason, they are not enabled by default. Experiment with --rlimits for hours of fun!

One of the techniques is parsing Haskell code for unimported qualifiers (because the GHC API is untrustworthy). The library used to parse is haskell-src-exts, as already mentioned; haskell-src-exts has a number of outstanding bugs, one of which is that it chokes sometimes on parsing code such as '(||)'. (I am given to understand the parentheses and pipes conflict with some internal things in it.) If expressions should mysteriously not parse and they contain fragments like the above, you can probably get it to work by simply adding some whitespace - not '(||)' but '( || )'.

Mueval also simply cannot do qualified imports. This is due to limitations in the GHC API; see <http://hackage.haskell.org/trac/ghc/ticket/1895>. (Remember that cc'ing yourself is an implicit vote for the problem to be fixed!)

CONTRIBUTING:
So, you've discovered a bug or other infelicity? If you can successfully build & install Mueval, but running it on expressions leads to errors, please send me an email at <gwern0@gmail.com>. Include in the email all the output you see if you run the informal test suite:

 sh$ sh tests.sh

If this script *does not* terminate with a success message, then there's something wrong. One of the properties Mueval strives to have is that on every bad expression, it errors out with an exit code of 1, and on every good expression, an exit code of 0.

If you have a patch handy, 'darcs send' is the best way to contribute. As above, tests.sh should be happy, as should 'cabal check'; even better is if your email is GPG-signed, but that's not as important as test.sh passing.